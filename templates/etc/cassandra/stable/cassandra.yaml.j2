# Cassandra storage config YAML - generated by Ansible

# NOTE:
#   See http://wiki.apache.org/cassandra/StorageConfiguration for
#   full explanations of configuration directives
# /NOTE

cluster_name: '{{ cassandra_cluster_name }}'

num_tokens: {{ cassandra_num_tokens }}

# initial_token allows you to specify tokens manually.  While you can use # it with
# vnodes (num_tokens > 1, above) -- in which case you should provide a 
# comma-separated list -- it's primarily used when adding nodes # to legacy clusters 
# that do not have vnodes enabled.
# initial_token:

hinted_handoff_enabled: {{ cassandra_hinted_handoff_enabled|lower }}
max_hint_window_in_ms: {{ cassandra_max_hint_window_in_ms }}
hinted_handoff_throttle_in_kb: {{ cassandra_hinted_handoff_throttle_in_kb }}
max_hints_delivery_threads: {{ cassandra_max_hints_delivery_threads }}

batchlog_replay_throttle_in_kb: {{ cassandra_batchlog_replay_throttle_in_kb }}

authenticator: {{ cassandra_authenticator }}

authorizer: {{ cassandra_authorizer }}

role_manager: {{ cassandra_role_manager }}

roles_validity_in_ms: {{ cassandra_roles_validity_in_ms }}

# Refresh interval for roles cache (if enabled).
# After this interval, cache entries become eligible for refresh. Upon next
# access, an async reload is scheduled and the old value returned until it
# completes. If roles_validity_in_ms is non-zero, then this must be
# also.
# Defaults to the same value as roles_validity_in_ms.
# roles_update_interval_in_ms: 1000

permissions_validity_in_ms: {{ cassandra_permissions_validity_in_ms }}

# Refresh interval for permissions cache (if enabled).
# After this interval, cache entries become eligible for refresh. Upon next
# access, an async reload is scheduled and the old value returned until it
# completes. If permissions_validity_in_ms is non-zero, then this must be
# also.
# Defaults to the same value as permissions_validity_in_ms.
# permissions_update_interval_in_ms: 1000

partitioner: {{ cassandra_partitioner }}

# Directories where Cassandra should store data on disk.  Cassandra
# will spread data evenly across them, subject to the granularity of
# the configured compaction strategy.
# If not set, the default directory is $CASSANDRA_HOME/data/data.
data_file_directories:
{% for dir in cassandra_data_file_directories %}
    - {{ dir }}
{% endfor %}

# commit log.  when running on magnetic HDD, this should be a
# separate spindle than the data directories.
# If not set, the default directory is $CASSANDRA_HOME/data/commitlog.
commitlog_directory: {{ cassandra_commitlog_directory }}

disk_failure_policy: {{ cassandra_disk_failure_policy }}

commit_failure_policy: {{ cassandra_commit_failure_policy }}

key_cache_size_in_mb: {{ cassandra_key_cache_size_in_mb }}

key_cache_save_period: {{ cassanra_key_cache_save_period }}

# Number of keys from the key cache to save
# Disabled by default, meaning all keys are going to be saved
# key_cache_keys_to_save: 100

row_cache_class_name: {{ cassandra_row_cache_class_name }}
row_cache_size_in_mb: {{ cassandra_row_cache_size_in_mb }}
row_cache_save_period: {{ cassandra_row_cache_save_period }}

# Number of keys from the row cache to save.
# Specify 0 (which is the default), meaning all keys are going to be saved
# row_cache_keys_to_save: 100

counter_cache_size_in_mb: {{ cassandra_counter_cache_size_in_mb }}
counter_cache_save_period: {{ cassandra_counter_cache_save_period }}
saved_caches_directory: {{ cassandra_saved_caches_directory }}
commitlog_sync: {{ cassandra_commitlog_sync }}
commitlog_sync_period_in_ms: {{ cassandra_commitlog_sync_period_in_ms }}
commitlog_segment_size_in_mb: {{ cassandra_commitlog_segment_size_in_mb }}
{% if cassandra_enable_commitlog_compression %}
commitlog_compression:
  - class_name: {{ cassandra_commitlog_compression_class }}
{% if cassandra_commitlog_compression and cassandra_commitlog_compression_params != None %}
    parameters:
{% for param in cassandra_commitlog_compression_params %}
        - {{ param }}
{% endfor %}
{% endif %}
{% endif %}

seed_provider:
    # Addresses of hosts that are deemed contact points. 
    # Cassandra nodes use this list of hosts to find each other and learn
    # the topology of the ring.  You must change this if you are running
    # multiple nodes!
    - class_name: {{ cassandra_seed_provider_class }}
      parameters:
          - seeds: "{% groups['cassandra_seeds']|join(',') %}"

concurrent_reads: {{ cassandra_concurrent_reads }}
concurrent_writes: {{ cassandra_concurrent_writes }}
concurrent_counter_writes: {{ cassandra_concurrent_counter_writes }}

# Total memory to use for sstable-reading buffers.  Defaults to
# the smaller of 1/4 of heap or 512MB.
# file_cache_size_in_mb: 512

# Total permitted memory to use for memtables. Cassandra will stop 
# accepting writes when the limit is exceeded until a flush completes,
# and will trigger a flush based on memtable_cleanup_threshold
# If omitted, Cassandra will set both to 1/4 the size of the heap.
# memtable_heap_space_in_mb: 2048
# memtable_offheap_space_in_mb: 2048

# Ratio of occupied non-flushing memtable size to total permitted size
# that will trigger a flush of the largest memtable. Larger mct will
# mean larger flushes and hence less compaction, but also less concurrent
# flush activity which can make it difficult to keep your disks fed
# under heavy write load.
#
# memtable_cleanup_threshold defaults to 1 / (memtable_flush_writers + 1)
# memtable_cleanup_threshold: 0.11

memtable_allocation_type: {{ cassandra_memtable_allocation_type }}

# Total space to use for commit logs on disk.
#
# If space gets above this value, Cassandra will flush every dirty CF
# in the oldest segment and remove it.  So a small total commitlog space
# will tend to cause more flush activity on less-active columnfamilies.
#
# The default value is the smaller of 8192, and 1/4 of the total space
# of the commitlog volume.
#
# commitlog_total_space_in_mb: 8192

# This sets the amount of memtable flush writer threads.  These will
# be blocked by disk io, and each one will hold a memtable in memory
# while blocked. 
#
# memtable_flush_writers defaults to the smaller of (number of disks,
# number of cores), with a minimum of 2 and a maximum of 8.
# 
# If your data directories are backed by SSD, you should increase this
# to the number of cores.
{% if cassandra_memtable_flush_writers != None %}
memtable_flush_writers: {{ cassandra_memtable_flush_writers }}
{% else %}
memtable_flush_writers: {{ ansible_processor_cores }}
{% endif %}

index_summary_capacity_in_mb: {{ cassandra_index_summary_capacity_in_mb }}
index_summary_resize_interval_in_minutes: {{ cassandra_index_summary_resize_interval_in_minutes }}

# Whether to, when doing sequential writing, fsync() at intervals in
# order to force the operating system to flush the dirty
# buffers. Enable this to avoid sudden dirty buffer flushing from
# impacting read latencies. Almost always a good idea on SSDs; not
# necessarily on platters.
trickle_fsync: {{ cassandra_trickle_fsync }}
trickle_fsync_interval_in_kb: {{ cassandra_trickle_fsync_interval_in_kb }}

# TCP port, for commands and data
# For security reasons, you should not expose this port to the internet.  Firewall it if needed.
storage_port: {{ cassandra_storage_port }}

# SSL port, for encrypted communication.  Unused unless enabled in
# encryption_options
# For security reasons, you should not expose this port to the internet.  Firewall it if needed.
ssl_storage_port: {{ cassandra_ssl_storage_port }}

# Address or interface to bind to and tell other Cassandra nodes to connect to.
# You _must_ change this if you want multiple nodes to be able to communicate!
#
# Set listen_address OR listen_interface, not both. Interfaces must correspond
# to a single address, IP aliasing is not supported.
#
# Leaving it blank leaves it up to InetAddress.getLocalHost(). This
# will always do the Right Thing _if_ the node is properly configured
# (hostname, name resolution, etc), and the Right Thing is to use the
# address associated with the hostname (it might not be).
#
# Setting listen_address to 0.0.0.0 is always wrong.
#
# If you choose to specify the interface by name and the interface has an ipv4 and an ipv6 address
# you can specify which should be chosen using listen_interface_prefer_ipv6. If false the first ipv4
# address will be used. If true the first ipv6 address will be used. Defaults to false preferring
# ipv4. If there is only one address it will be selected regardless of ipv4/ipv6.
listen_address: {{ ['ansible_all_ipv4_addresses'] | last }}
# listen_interface: eth0
# listen_interface_prefer_ipv6: false

# Address to broadcast to other Cassandra nodes
# Leaving this blank will set it to the same value as listen_address
# broadcast_address: 1.2.3.4

internode_authenticator: {{ cassandra_internode_authenticator }}

start_native_transport: {{ cassandra_start_native_transport }}
native_transport_port: {{ cassandra_native_transport_port }}

native_transport_max_threads: {{ cassandra_native_transport_max_threads }}
native_transport_max_frame_size_in_mb: {{ cassandra_native_transport_max_frame_size_in_mb }}

native_transport_max_concurrent_connections: {{ cassandra_native_transport_max_concurrent_connections }}
native_transport_max_concurrent_connections_per_ip: {{ cassandra_native_transport_max_concurrent_connections_per_ip }}

start_rpc: {{ cassandra_start_rpc|lower }}

# The address or interface to bind the Thrift RPC service and native transport
# server to.
#
# Set rpc_address OR rpc_interface, not both. Interfaces must correspond
# to a single address, IP aliasing is not supported.
#
# Leaving rpc_address blank has the same effect as on listen_address
# (i.e. it will be based on the configured hostname of the node).
#
# Note that unlike listen_address, you can specify 0.0.0.0, but you must also
# set broadcast_rpc_address to a value other than 0.0.0.0.
#
# For security reasons, you should not expose this port to the internet.  Firewall it if needed.
#
# If you choose to specify the interface by name and the interface has an ipv4 and an ipv6 address
# you can specify which should be chosen using rpc_interface_prefer_ipv6. If false the first ipv4
# address will be used. If true the first ipv6 address will be used. Defaults to false preferring
# ipv4. If there is only one address it will be selected regardless of ipv4/ipv6.
rpc_address: {{ ['ansible_all_ipv4_addresses'] | last }}
# rpc_interface: eth1
# rpc_interface_prefer_ipv6: false

# port for Thrift to listen for clients on
rpc_port: {{ cassandra_rpc_port }}

# RPC address to broadcast to drivers and other Cassandra nodes. This cannot
# be set to 0.0.0.0. If left blank, this will be set to the value of
# rpc_address. If rpc_address is set to 0.0.0.0, broadcast_rpc_address must
# be set.
# broadcast_rpc_address: 1.2.3.4

# enable or disable keepalive on rpc/native connections
rpc_keepalive: {{ cassandra_rpc_keepalive|lower }}

# Cassandra provides two out-of-the-box options for the RPC Server:
#
# sync  -> One thread per thrift connection. For a very large number of clients, memory
#          will be your limiting factor. On a 64 bit JVM, 180KB is the minimum stack size
#          per thread, and that will correspond to your use of virtual memory (but physical memory
#          may be limited depending on use of stack space).
#
# hsha  -> Stands for "half synchronous, half asynchronous." All thrift clients are handled
#          asynchronously using a small number of threads that does not vary with the amount
#          of thrift clients (and thus scales well to many clients). The rpc requests are still
#          synchronous (one thread per active request). If hsha is selected then it is essential
#          that rpc_max_threads is changed from the default value of unlimited.
#
# The default is sync because on Windows hsha is about 30% slower.  On Linux,
# sync/hsha performance is about the same, with hsha of course using less memory.
#
# Alternatively,  can provide your own RPC server by providing the fully-qualified class name
# of an o.a.c.t.TServerFactory that can create an instance of it.
rpc_server_type: {{ cassandra_rpc_server_type }}

# Uncomment rpc_min|max_thread to set request pool size limits.
#
# Regardless of your choice of RPC server (see above), the number of maximum requests in the
# RPC thread pool dictates how many concurrent requests are possible (but if you are using the sync
# RPC server, it also dictates the number of clients that can be connected at all).
#
# The default is unlimited and thus provides no protection against clients overwhelming the server. You are
# encouraged to set a maximum that makes sense for you in production, but do keep in mind that
# rpc_max_threads represents the maximum number of client requests this server may execute concurrently.
#
rpc_min_threads: {{ cassandra_rpc_min_threads }}
rpc_max_threads: {{ cassandra_rpc_max_threads }}

# uncomment to set socket buffer sizes on rpc connections
# rpc_send_buff_size_in_bytes:
# rpc_recv_buff_size_in_bytes:

# Uncomment to set socket buffer size for internode communication
# Note that when setting this, the buffer size is limited by net.core.wmem_max
# and when not setting it it is defined by net.ipv4.tcp_wmem
# See:
# /proc/sys/net/core/wmem_max
# /proc/sys/net/core/rmem_max
# /proc/sys/net/ipv4/tcp_wmem
# /proc/sys/net/ipv4/tcp_wmem
# and: man tcp
# internode_send_buff_size_in_bytes:
# internode_recv_buff_size_in_bytes:

# Frame size for thrift (maximum message length).
thrift_framed_transport_size_in_mb: {{ cassandra_thrift_framed_transport_size_in_mb }}

# Set to true to have Cassandra create a hard link to each sstable
# flushed or streamed locally in a backups/ subdirectory of the
# keyspace data.  Removing these links is the operator's
# responsibility.
incremental_backups: {{ cassandra_incremental_backups|lower }}

# Whether or not to take a snapshot before each compaction.  Be
# careful using this option, since Cassandra won't clean up the
# snapshots for you.  Mostly useful if you're paranoid when there
# is a data format change.
snapshot_before_compaction: {{ cassandra_snapshot_before_compaction|lower }}

# Whether or not a snapshot is taken of the data before keyspace truncation
# or dropping of column families. The STRONGLY advised default of true 
# should be used to provide data safety. If you set this flag to false, you will
# lose data on truncation or drop.
auto_snapshot: {{ cassandra_auto_snapshot|lower }}

tombstone_warn_threshold: {{ cassandra_tombstone_warn_threshold }}
tombstone_failure_threshold: {{ cassandra_tombstone_failure_threshold }}

column_index_size_in_kb: {{ cassandra_column_index_size_in_kb }}
batch_size_warn_threshold_in_kb: {{ cassandra_batch_size_warn_threshold_in_kb }}
batch_size_fail_threshold_in_kb: {{ cassandra_batch_size_fail_threshold_in_kb }}

# Number of simultaneous compactions to allow, NOT including
# validation "compactions" for anti-entropy repair.  Simultaneous
# compactions can help preserve read performance in a mixed read/write
# workload, by mitigating the tendency of small sstables to accumulate
# during a single long running compactions. The default is usually
# fine and if you experience problems with compaction running too
# slowly or too fast, you should look at
# compaction_throughput_mb_per_sec first.
#
# concurrent_compactors defaults to the smaller of (number of disks,
# number of cores), with a minimum of 2 and a maximum of 8.
# 
# If your data directories are backed by SSD, you should increase this
# to the number of cores.
concurrent_compactors: {{ ansible_processor_cores }}
compaction_throughput_mb_per_sec: {{ cassandra_compaction_throughput_mb_per_sec }}
compaction_large_partition_warning_threshold_mb: {{ cassandra_compaction_large_partition_warning_threshold_mb }}

sstable_preemptive_open_interval_in_mb: {{ cassandra_sstable_preemptive_open_interval_in_mb }}

stream_throughput_outbound_megabits_per_sec: {{ cassandra_stream_throughput_outbound_megabits_per_sec }}
inter_dc_stream_throughput_outbound_megabits_per_sec: {{ cassandra_inter_dc_stream_throughput_outbound_megabits_per_sec }}

read_request_timeout_in_ms: {{ cassandra_read_request_timeout_in_ms }}
range_request_timeout_in_ms: {{ cassandra_range_request_timeout_in_ms }}
write_request_timeout_in_ms: {{ cassandra_write_request_timeout_in_ms }}
counter_write_request_timeout_in_ms: {{ cassandra_counter_write_request_timeout_in_ms }}
cas_contention_timeout_in_ms: {{ cassandra_cas_contention_timeout_in_ms }}
truncate_request_timeout_in_ms: {{ cassandra_truncate_request_timeout_in_ms }}
request_timeout_in_ms: {{ cassandra_request_timeout_in_ms }}

cross_node_timeout: {{ cassandra_cross_node_timeout|lower }}

streaming_socket_timeout_in_ms: {{ cassandra_streaming_socket_timeout_in_ms }}

phi_convict_threshold: {{ cassandra_phi_convict_threshold }}

endpoint_snitch: {{ cassandra_endpoint_snitch }}

dynamic_snitch_update_interval_in_ms: {{ cassandra_dynamic_snitch_update_interval_in_ms }}
dynamic_snitch_reset_interval_in_ms: {{ cassandra_dynamic_snitch_reset_interval_in_ms }}
dynamic_snitch_badness_threshold: {{ cassandra_dynamic_snitch_badness_threshold }}

# request_scheduler -- Set this to a class that implements
# RequestScheduler, which will schedule incoming client requests
# according to the specific policy. This is useful for multi-tenancy
# with a single Cassandra cluster.
# NOTE: This is specifically for requests from the client and does
# not affect inter node communication.
# org.apache.cassandra.scheduler.NoScheduler - No scheduling takes place
# org.apache.cassandra.scheduler.RoundRobinScheduler - Round robin of
# client requests to a node with a separate queue for each
# request_scheduler_id. The scheduler is further customized by
# request_scheduler_options as described below.
request_scheduler: org.apache.cassandra.scheduler.NoScheduler

# Scheduler Options vary based on the type of scheduler
# NoScheduler - Has no options
# RoundRobin
#  - throttle_limit -- The throttle_limit is the number of in-flight
#                      requests per client.  Requests beyond 
#                      that limit are queued up until
#                      running requests can complete.
#                      The value of 80 here is twice the number of
#                      concurrent_reads + concurrent_writes.
#  - default_weight -- default_weight is optional and allows for
#                      overriding the default which is 1.
#  - weights -- Weights are optional and will default to 1 or the
#               overridden default_weight. The weight translates into how
#               many requests are handled during each turn of the
#               RoundRobin, based on the scheduler id.
#
# request_scheduler_options:
#    throttle_limit: 80
#    default_weight: 5
#    weights:
#      Keyspace1: 1
#      Keyspace2: 5

# request_scheduler_id -- An identifier based on which to perform
# the request scheduling. Currently the only valid option is keyspace.
request_scheduler_id: {{ cassandra_request_scheduler_id }}

# Enable or disable inter-node encryption
# Default settings are TLS v1, RSA 1024-bit keys (it is imperative that
# users generate their own keys) TLS_RSA_WITH_AES_128_CBC_SHA as the cipher
# suite for authentication, key exchange and encryption of the actual data transfers.
# Use the DHE/ECDHE ciphers if running in FIPS 140 compliant mode.
# NOTE: No custom encryption options are enabled at the moment
# The available internode options are : all, none, dc, rack
#
# If set to dc cassandra will encrypt the traffic between the DCs
# If set to rack cassandra will encrypt the traffic between the racks
#
# The passwords used in these options must match the passwords used when generating
# the keystore and truststore.  For instructions on generating these files, see:
# http://download.oracle.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html#CreateKeystore
#
server_encryption_options:
    internode_encryption: {{ cassandra_internode_encryption }}
    keystore: {{ cassandra_keystore }}
    keystore_password: {{ cassandra_keystore_password }}
    truststore: {{ cassandra_truststore }}
    truststore_password: {{ cassandra_truststore_password }}
    protocol: {{ cassandra_protocol }}
    algorithm: {{ cassandra_algorithm }}
    store_type: {{ cassandra_store_type }}
    cipher_suites: [{{ cassandra_cipher_suites|join(',') }}]
    require_client_auth: {{ cassandra_require_client_auth|lower }}

# enable or disable client/server encryption.
client_encryption_options:
    enabled: {{ cassandra_client_encryption_enabled|lower }}
    # If enabled and optional is set to true encrypted and unencrypted connections are handled.
    optional: {{ cassandra_client_encryption_optional|lower }}
    keystore: {{ cassandra_client_encryption_keystore }}
    keystore_password: {{ cassandra_client_encryption_keystore_password }}
    require_client_auth: {{ cassandra_client_encryption_require_client_auth|lower }}
    # Set trustore and truststore_password if require_client_auth is true
    truststore: {{ cassandra_client_encryption_truststore }}
    truststore_password: {{ cassandra_client_encryption_truststore_password }}
    protocol: {{ cassandra_client_encryption_protocol }}
    algorithm: {{ cassandra_client_encryption_algorithm }}
    store_type: {{ cassandra_client_encryption_store_type }}
    cipher_suites: [{{ cassandra_client_encryption_cipher_suites|join(',') }}]

# internode_compression controls whether traffic between nodes is
# compressed.
# can be:  all  - all traffic is compressed
#          dc   - traffic between different datacenters is compressed
#          none - nothing is compressed.
internode_compression: {{ cassandra_internode_compression }}

# Enable or disable tcp_nodelay for inter-dc communication.
# Disabling it will result in larger (but fewer) network packets being sent,
# reducing overhead from the TCP protocol itself, at the cost of increasing
# latency if you block for cross-datacenter responses.
inter_dc_tcp_nodelay: {{ cassandra_inter_dc_tcp_nodelay|lower }}

# TTL for different trace types used during logging of the repair process.
tracetype_query_ttl: {{ cassandra_tracetype_query_ttl }}
tracetype_repair_ttl: {{ cassandra_tracetype_repair_ttl }}

# GC Pauses greater than gc_warn_threshold_in_ms will be logged at WARN level
# Adjust the threshold based on your application throughput requirement
# By default, Cassandra logs GC Pauses greater than 200 ms at INFO level
gc_warn_threshold_in_ms: {{ cassandra_gc_warn_threshold_in_ms }}

# UDFs (user defined functions) are disabled by default.
# As of Cassandra 2.2, there is no security manager or anything else in place that
# prevents execution of evil code. CASSANDRA-9402 will fix this issue for Cassandra 3.0.
# This will inherently be backwards-incompatible with any 2.2 UDF that perform insecure
# operations such as opening a socket or writing to the filesystem.
enable_user_defined_functions: {{ cassandra_enable_user_defined_functions|lower }}

# The default Windows kernel timer and scheduling resolution is 15.6ms for power conservation.
# Lowering this value on Windows can provide much tighter latency and better throughput, however
# some virtualized environments may see a negative performance impact from changing this setting
# below their system default. The sysinternals 'clockres' tool can confirm your system's default
# setting.
windows_timer_interval: {{ cassandra_windows_timer_interval }}
